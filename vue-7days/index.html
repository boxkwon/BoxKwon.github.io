<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BoxKwon.github.io</title>
</head>
<body>
    <h1>Vue.js 7day 프로젝트</h1>

    <h2>2021.07.18</h2>
    <ol>
        <li>
            <h3>학습 계획 (영상 기준)</h3>
            <ul>
                <li>강의 시간 총 8시간 36분을 7일로 나누어 하루 1시간 10분 분량의 영상을 학습한다.</li>
                <li>섹션0 ~ 섹션1은 사전 학습하여 섹션 2부터 기록한다.</li>
                <li>금일 목표 - 섹션2, 섹션3 완료. 강의 시간 74분 11초</li>
            </ul>
        </li>
        <li>
            <h3>Vue CLI 설치</h3>
            <ul>
                <li>vue 프로젝트를 구성하고 빌드하고 디플로이까지하는 유용한 도구이다.</li>
                <li>vue 프로젝트의 폴더 구조, 필요한 파일들, 기본 설정 옵션을 명령어를 통해 자동으로 만들어 준다.</li>
                <li>
                    <ol>
                        <h4>vue 프로젝트를 만드는 방법은 3가지가 있다.</h4>
                        <li>Default 옵션으로 생성</li>
                        <li>Manually select features 옵션으로 생성</li>
                        <li>Vue 프로젝트 매니저로 생성</li>
                    </ol>
                </li>
            </ul>
        </li>
        <li>
            <h3>Default 옵션으로 Vue 프로젝트 생서하기</h3>
            <ul>
                <li>vue create 프로젝트명</li>
                <li>설치 후 npm run serve를 입력하여 서버 시작.</li>
                <li>
                    <p><strong>main.js</strong></p>
                    <p>-> main.js가 가장먼저 실행이 되고 우리가 개발한 vue 컴퍼넌트를 실행한다.</p>
                    <p>-> index.html 을 통해 우리가 만든 vue컴퍼넌트들이 결국은 사용자에게 제공된다.</p>
                </li>
            </ul>
        </li>
    </ol>
    <hr>
    <h2>2021.07.22</h2>
    <ol>
        <li>
            <h3>Vue Router 설치하기</h3>
            <ul>
                <li>클라이언트에서 미리 가지고있던 페이지를 라우팅을 이용해서 페이지를 갱신하는 방법</li>
            </ul>
        </li>
    </ol>
    <hr>
    <h2>2021.07.24</h2>
    <ol>
        <li>
            <h3>Lazy Load (비동기 컴포넌트) 구성하기</h3>
            <ul>
                <li>리소스를 컴포넌트 단위로 분리하여 컴포넌트 혹은 라우터 단위로 필요한 것들만 그때 그때 다운받을 수 있게 하는 방법이다.</li>
                <li>Vue에서 Lazy Load는 Vue CLI의 prefetch 기능을 사용한 것이다.</li>
                <li>prefetch 기능은 about.vue의 코드가 about.js로 별도로 분리되어 load가 된다.</li>
                <li>사이트 최초 로드시 about.js는 메모리(캐시)에 등록하기 때문에 (서버에 리퀘스트를 보내고 리스폰스를 받기 때문에) prefetch가 많을수록 로딩이 느려진다.</li>
                <li>vue.config.js 파일을 생성하여 dnpqvor chainWebpack 이라고 키를 잡고 prefetch를 사용하지 않도록 설정한다.</li>
                <li>* config.js를 재설성 했을경우 서버를 재부팅 하여야 한다.</li>
                <li>아래 세가지 방법을 적절히 설계하는것이 vue 프로젝트에서 성능 향상을 위한 굉장히 중요한 부분 중 하나이다.</li>
                <li>-> 1. prefetch 기능을 사용안하던가.</li>
                <li>-> * 2. 초기에 사용가 바로 다음 접속 할 가능성이 높은 페이지(컴퍼넌트)를 예상하여 필요한 것만 prefetch 기능을 사용하던가.</li>
                <li>-> 3. 처음에 모두 prefetch 하던가.</li>
                <li>초기 세팅 뿐만 아니라 운영시에도 사용자의 사용 빈도 현황 조사를 통해서 지속적인 라우터 설정 개선을 해주어야 한다.</li>
            </ul>
        </li>
    </ol>
    <hr>
    <h2>2021.07.25</h2>
    <ol>
        <li>
            <h3>Vue 컴포넌트 기본구조 이해하기</h3>
            <ul>
                <li>View, Data, Code의 세트이다</li>
                <li>컴포넌트 내부에는 HTML 코드가 있고, 이 HTML 코드를 실행하기 위한 자바스크립트 코드와 데이터가 존재한다.</li>
                <li>컴포넌트의 가장 큰 특징은 재상요 가능한 것이다.</li>
                <li>views 폴더에 vue 컴포넌트 파일을 생성한다.</li>
                <li>components 폴더에는 다른 vue 파일을 호출해서 공통으로 사용할 수 있는 vue 컴포넌트 파일을 생성하고 관리한다.</li>
                <li>물리적으로 프로젝트 폴더를 구분해서 사용하는 것이 관리적인 차원에서 훨씬 효율적이다.</li>
            </ul>
        </li>
    </ol>
    <hr>
    <h2>2021.07.27</h2>
    <ol>
        <li>
            <h3>raw(원시) HTML 데이터 바인딩</h3>
            <ul>
                <li>html 태그를 이중 중괄호를 이용해서 바인딩 하면 문자열로 인식된다.</li>
                <li>HTML로 출력하려면 v-html 디렉티브를 사용해야 한다.</li>
            </ul>
        </li>
    </ol>
    <hr>
    <h2>2021.07.29 ~ 2021.07.31 여름 휴가</h2>
    <hr>
    <h2>2021.08.01</h2>
    <ol>
        <li>
            <h3>입력폼 데이터 바인딩 - input text, number, textarea</h3>
            <ul>
                <li>input type=text</li>
                <li>-> v-model은 내부적으로 value속성을 사용하여 data()에 저의된 데이터 키명을 v-model에 넣어주면 양방향 데이터 바인딩이 된다.</li>
                <li>input type=number</li>
                <li>-> string이 아닌 수자로 바로 처리할수 있도록 v-model.number 디렉티브를 사용하여야 한다.</li>
                <li>textarea</li>
                <li>-> 태그의 속성으로 v-model에 정의 하여야 한다.</li>
            </ul>
        </li>
    </ol>
    <hr>
    <h2>2021.08.02</h2>
    <ol>
        <li>
            <h3>입력폼 데이터 바인딩 - select, checkbox, radio</h3>
            <ul>
                <li>select</li>
                <li>-> v-model은 내부적으로 value 속성을 사용하여 양방향 데이터 바인딩을 한다.</li>
                <li>-> data에서 정의한 키를 맵핑하면 select 객체의 초기값을 설정할수 있다.</li>
                <li>checkbox</li>
                <li>-> v-model은 내부적으로 checked 속성을 사용한다.</li>
                <li>-> v-model이 아닌 v-bind:value를 사용해야 한다.</li>
                <li>-> 여러 개의 체크박스를 사용할 때는 배열을 이용해서 데이터 바인딩을 한 번에 처리할 수 있다.</li>
                <li>radio</li>
                <li>-> v-model은 내부적으로 checked 속성을 사용하여 양방향 데이터 바이닝을 한다.</li>
                <li>-> v-model이 아닌 v-bind:value를 사용해야 한다.</li>
            </ul>
        </li>
    </ol>
    <hr>
    <h2>2021.08.04</h2>
    <ol>
        <li>
            <h3>속성(attribute)에 데이터 바인딩</h3>
            <ul>
                <li>HTML 객체의 속성(attribute)에 데이터를 바인딩 하기 위해서 v-bind: 디렉티브를 사용한다.</li>
                <li>-> v-bind: 는 :(콜론)으로 대체할 수 있다.</li>
                <li>img 객체의 src</li>
                <li>-> v-bind:src="url"</li>
                <li>-> data에 정의한 url을 img 객체의 src속성에 바인딩 한다.</li>
                <li>button 객체의 disabled</li>
                <li>-> v-bind:disabled="textValue=''"</li>
                <li>-> input text의 v-model을 textValue와 바인딩 한다.</li>
                <li>-> textValue의 값이 공백으로 ture이면 disabled 속성도 true 이므로 비활성화, false이면 활성화 된다.</li>
            </ul>
        </li>
    </ol>
    <hr>
    <h2>2021.08.05</h2>
    <ol>
        <li>
            <h3>클래스와 스타일에 데이터 바인딩</h3>
            <ul>
                <li>반드시 적용해야 하는 클래스는 기존 html의 class 속성에 정의한다.</li>
                <li>조건에 따라 바인딩할 클래스의 경우는 v-bind:class를 이용해서 추가한다.</li>
                <li>오브젝트 형태로 사용하며, 바인딩할 클래스를 Key로 잡고, 바인딩 여부를 true/false로 지정한다.</li>
                <li>배열을 사용하여 클래스 바인딩 할 수도 있지만, 조건에 따른 바인딩 처리를 true/false로 할 수 없다.</li>
            </ul>
        </li>
    </ol>
    <hr>
    <h2>2021.08.06</h2>
    <ol>
        <li>
            <h3>클래스와 스타일에 데이터 바인딩</h3>
            <ul>
                <li>데이터를 오브젝트로 선언해서 바인딩할 수 있다.</li>
                <li>클래스 바인드와 마찬가지로 배열을 사용하여 바인딩 할 수 있다.</li>
            </ul>
        </li>
    </ol>
    <hr>
    <h2>2021.08.06</h2>
    <ol>
        <li>
            <h3>리스트 랜더링(v-for)</h3>
            <ul>
                <li>실무에서 주로 많이 사용되는 다중 데이터 처리는 select의 option, table의 tr 데이터 등이 있다.</li>
                <li>동일한 UI패턴에 데이터만 다르게 처리되는 부분들 이라고 보면 된다.</li>
                <li>배열 데이터는 v-for 디렉티브를 이용해서 바인딩 한다.</li>
                <li>v-for="(item, index) in items"</li>
                <li>-> items는 데이터 배열이다.</li>
                <li>v-for를 통해 배열을 하나씩 읽어와서 배열의 각 아이템을 item으로, 배열의 현재 index를 index로 반환해 준다.</li>
            </ul>
        </li>
    </ol>
    <hr>
    <h2>2021.08.07</h2>
    <ol>
        <li>
            <h3>랜더링 문법(v-if, v-show)</h3>
            <ul>
                <li>v-if</li>
                <li>-> true가 리턴되면 html 블록이 랜더링 되고, false인 경우는 해당 블록 전체를 생성했다가 삭제된다.</li>
                <li>-> 해당 블록에 toggle이 일어날 때 해당 블록 전체를 생성했다가 삭제하기 때문에 많은 자원을 사용하게 된다.</li>
                <li>v-show</li>
                <li>-> 조건에 만족하지 않아도 html 블럭은 렌더링이 되고 css의 display 속성으로 none 처리가 된다.</li>
                <li>-> 조건 만족 여부와 상관없이 무조건 생성되기 때문에 초기에 html 블록을 생성하는데 자원을 사용한다.</li>
                <li>*실무에서는 html 블록이 화면 내에서 자주 toggle 발생하면 v-show를, 빈도가 적다면 v-if를 사용하는것이 좋다.</li>
            </ul>
        </li>
    </ol>
    <hr>
    <h2>2021.08.08</h2>
    <ol>
        <li>
            <h3>이벤트 처리(v-on)</h3>
            <ul>
                <li>v-on:click="메소드명(파라미터)" 또는 @click="메소드명(파라미터)"</li>
                <li>-> 클릭 이벤트를 통해 지정된 함수로 파라미터를 전달 하려면 함수 호출시 파라미터 설정한다.</li>
                <li>@click="one(), two()"</li>
                <li>-> 여러 개의 함수 호출시 "," 콤마로 구분하여 추가한다.</li>
                <li>@change="메소드명(파라미터)"</li>
                <li>-> 주로 select에 많이 쓰인다.</li>
                <li>@keyup.이벤트명</li>
                <li>-> .enter, .tab, .delete(Del, Backspace), .esc, .right, .space</li>
                <li>@keyup.alt.enter, @click.ctrl</li>
                <li>-> Control, Shift, Alt키와 같이 다른 키와 같이 사용되는 특수 키도 처리할수 있다.</li>
            </ul>
        </li>
    </ol>
    <hr>
    <h2>2021.08.12</h2>
    <ol>
        <li>
            <h3>Computed</h3>
            <ul>
                <li>Vue 인스턴스 내에 정의된 데이터 값에 변경이 일어 나는지 감시하고, 변경될 때마다 정의된 함수가 실행된다.</li>
                <li>Computed 내에 정의한 함수는 함수이자 동시에, Vue 인스턴스의 동일한 데이터 키 값으로 선언 된다.</li>
            </ul>
        </li>
    </ol>
    <hr>
</body>
</html>